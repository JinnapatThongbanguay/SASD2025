## Data Class 
**1. ความหมายของ Data Class**

Data Class คือคลาสที่มีหน้าที่แค่เก็บข้อมูล (data holder) โดยประกอบด้วย fields, getters (อ่านค่า), setters (แก้ไขค่า) แต่ไม่มี behavior หรือ logic ที่ทำงานกับข้อมูลนั้น ๆ 

**ทำไมถือเป็น code smell ?** (Code smell: เป็นสัญญาณที่บอกว่าโค้ดอาจมีปัญหาในการออกแบบ)

* ละเมิดหลักการ OOP ที่บอกว่าข้อมูลและ behavior ควรอยู่ด้วยกัน
* คลาสอื่น ๆ ต้องดึงข้อมูลออกมาประมวลผล ทำให้เกิด logic กระจัดกระจายไปทั่ว
* ข้อมูลถูกเปิดให้แก้ไขได้จากหลายที่ ทำให้ควบคุมการเปลี่ยนแปลงได้ยาก

**Data Class เป็น code smell เมื่อ:**

* มีแต่ getters/setters ไม่มี behavior
* Logic ที่เกี่ยวข้องกระจายอยู่ในคลาสอื่น
* ควรมี responsibility มากกว่าแค่เก็บข้อมูล

**2. ตัวอย่างโค้ดที่เกิด Data Class**
```// Data Class ที่มีปัญหา
public class Customer {
    private String name;
    private int age;
    private double totalPurchase;
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
    
    public double getTotalPurchase() { return totalPurchase; }
    public void setTotalPurchase(double totalPurchase) { 
        this.totalPurchase = totalPurchase; 
    }
}

// คลาสอื่นๆ ต้องดึงข้อมูลมาคำนวณเอง
public class DiscountCalculator {
    public double calculateDiscount(Customer customer) {
        // Logic กระจายอยู่นอก Customer class
        if (customer.getTotalPurchase() > 10000) {
            return customer.getTotalPurchase() * 0.1; // ส่วนลด 10%
        } else if (customer.getTotalPurchase() > 5000) {
            return customer.getTotalPurchase() * 0.05; // ส่วนลด 5%
        }
        return 0;
    }
}

public class CustomerType {
    public String getType(Customer customer) {
        // Logic อีกส่วนกระจายอยู่อีกที่
        if (customer.getAge() >= 60) {
            return "Senior";
        } else if (customer.getAge() >= 18) {
            return "Adult";
        }
        return "Youth";
    }
}
```
**ปัญหาที่เกิดขึ้น:**
* Logic ที่เกี่ยวข้องกับ Customer กระจัดกระจายอยู่หลายคลาส
* ถ้าต้องเปลี่ยนวิธีคำนวณส่วนลด ต้องไปแก้ในคลาสอื่นด้วย ทำให้ยุ่งยาก
* ข้อมูลถูกเปิดเผยผ่าน getter/setter มากเกินไป

**3. ตัวอย่างโค้ดที่ Refactor แล้ว**

```
// Refactored: เพิ่ม behavior เข้าไปในคลาส
public class Customer {
    private String name;
    private int age;
    private double totalPurchase;
    
    public Customer(String name, int age, double totalPurchase) {
        this.name = name;
        this.age = age;
        this.totalPurchase = totalPurchase;
    }
    
    // Getters อย่างเดียว (ไม่มี setters เพื่อป้องกันการแก้ไขข้อมูล)
    public String getName() { return name; }
    
    // เพิ่ม behavior ที่เกี่ยวข้องกับข้อมูล
    public double calculateDiscount() {
        if (totalPurchase > 10000) {
            return totalPurchase * 0.1;
        } else if (totalPurchase > 5000) {
            return totalPurchase * 0.05;
        }
        return 0;
    }
    
    public String getCustomerType() {
        if (age >= 60) {
            return "Senior";
        } else if (age >= 18) {
            return "Adult";
        }
        return "Youth";
    }
    
    public double getFinalPrice() {
        return totalPurchase - calculateDiscount();
    }
    
    public boolean isVIP() {
        return totalPurchase > 10000;
    }
}

// การใช้งาน
Customer customer = new Customer("จิณณพัต", 21, 12000);
double discount = customer.calculateDiscount(); // เรียกใช้ behavior ของตัวเอง
String type = customer.getCustomerType();
```

**ข้อดีหลัง Refactor:**
* Logic ทั้งหมดรวมอยู่ในที่เดียว ทำให้ง่ายต่อการดูแลรักษา (กลับมาแก้โค้ดภายหลังแล้ว ไม่ต้องแก้หลายที่ ไม่พังส่วนอื่น และเข้าใจได้ง่าย)
* ข้อมูลถูกป้องกันด้วย encapsulation
* เป็นไปตามหลักการ OOP ที่ข้อมูลและ behavior อยู่ในคลาสเดียวกัน

**4. กรณีที่ไม่จำเป็นต้อง Refactor**

**กรณีที่ 1:** Data Transfer Object (DTO)

~~~
// DTO สำหรับส่งข้อมูลระหว่าง API
public class UserDTO {
    private String username;
    private String email;
    private String phone;
    
    // getters และ setters
    // ไม่ต้องมี behavior เพราะหน้าที่คือส่งข้อมูลอย่างเดียว
}
~~~

เพราะ DTO ออกแบบมาเพื่อส่งข้อมูลระหว่างชั้นต่างๆ (เช่น API, Database) ไม่ได้ใช้ประมวลผล


**กรณีที่ 2:** Value Objects / Data Models
```
// Model ที่แทนข้อมูลจาก Database
public class ProductEntity {
    private Long id;
    private String productName;
    private BigDecimal price;
    private LocalDateTime createdAt;
    
    // getters และ setters
    // ใช้กับ ORM frameworks เช่น Hibernate, JPA
}
```
เพราะ คลาสประเภทนี้เป็นแค่ตัวแทนข้อมูลที่เก็บในฐานข้อมูล ไม่ได้มีหน้าที่ตัดสินใจหรือคำนวณ

**กรณีที่ 3:** Configuration Classes
```
// คลาสสำหรับเก็บการตั้งค่า
public class AppConfig {
    private String databaseUrl;
    private int maxConnections;
    private boolean debugMode;
    
    // getters และ setters
}
```

เพราะ เป็นแค่การเก็บค่า configuration ไม่มี behavior หรือ logic ที่เกี่ยวข้องกับการประมวลผล

**กรณีที่ 4:** Simple Data Containers
```
// จุดพิกัดง่ายๆ
public class Point {
    public final double x;
    public final double y;
    
    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }
}
```
เพราะ เป็นข้อมูลพื้นฐานที่มีโครงสร้างเรียบง่ายเลยไม่จำเป็นต้องมี behavior หรือการประมวลผลที่ซับซ้อน
